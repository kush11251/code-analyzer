"""Simple multi-language static vulnerability scanner.

This module provides a small, dependency-free static analysis engine that
looks for common insecure patterns in several popular languages. It is
not a replacement for professional security tooling, but it is useful as
an example / lightweight checker for this project.

Supported languages (by file extension):
- Python: .py
- JavaScript / TypeScript: .js, .mjs, .cjs, .ts
- Java: .java
"""

from __future__ import annotations

import os
import re
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence

# Directories that will be skipped during traversal
# These include VCS metadata, virtualenvs, caches, and common build / output
# folders used by tools like Angular, React, and TypeScript.
EXCLUDED_DIRS = {
    ".git",
    ".hg",
    ".svn",
    "__pycache__",
    "venv",
    ".venv",
    "node_modules",
    ".mypy_cache",
    ".pytest_cache",
    # Common build / output folders
    "dist",
    "build",
    "out",
    "out-tsc",
    ".angular",
    "coverage",
    ".cache",
}

# Very small language detector based on file extension
EXTENSION_LANGUAGE: Dict[str, str] = {
    ".py": "python",
    ".js": "javascript",
    ".mjs": "javascript",
    ".cjs": "javascript",
    # Treat TypeScript separately so we can attach additional TS-specific rules
    ".ts": "typescript",
    ".java": "java",
}


@dataclass
class Rule:
    """Represents a simple pattern-based security rule."""

    id: str
    description: str
    pattern: re.Pattern
    severity: str  # e.g. "low", "medium", "high"


@dataclass
class Vulnerability:
    """Represents a single potential vulnerability finding."""

    rule_id: str
    description: str
    severity: str
    language: str
    file_path: str
    line: int
    code: str

    def to_dict(self) -> Dict[str, object]:
        return asdict(self)


def _compile(pattern: str, ignore_case: bool = False) -> re.Pattern:
    flags = re.MULTILINE
    if ignore_case:
        flags |= re.IGNORECASE
    return re.compile(pattern, flags)


PYTHON_RULES: Sequence[Rule] = (
    Rule(
        id="PY001",
        description="Use of eval() can lead to code injection vulnerabilities.",
        pattern=_compile(r"\beval\("),
        severity="high",
    ),
    Rule(
        id="PY002",
        description="Use of exec() can lead to code injection vulnerabilities.",
        pattern=_compile(r"\bexec\("),
        severity="high",
    ),
    Rule(
        id="PY003",
        description="subprocess with shell=True is dangerous and can lead to command injection.",
        pattern=_compile(r"subprocess\.(Popen|call|run)\([^)]*shell\s*=\s*True"),
        severity="high",
    ),
    Rule(
        id="PY004",
        description="pickle.load(s) on untrusted data can lead to arbitrary code execution.",
        pattern=_compile(r"pickle\.load(s)?\("),
        severity="high",
    ),
    Rule(
        id="PY005",
        description="yaml.load() without a safe loader is unsafe; use yaml.safe_load().",
        pattern=_compile(r"yaml\.load\("),
        severity="medium",
    ),
    Rule(
        id="PY006",
        description="Use of weak hash algorithms (MD5/SHA1).",
        pattern=_compile(r"hashlib\.(md5|sha1)\("),
        severity="medium",
    ),
    Rule(
        id="PY007",
        description="Possible hard-coded password.",
        pattern=_compile(r"password\s*=\s*['\"].+['\"]", ignore_case=True),
        severity="medium",
    ),
)


JAVASCRIPT_RULES: Sequence[Rule] = (
    Rule(
        id="JS001",
        description="Use of eval() can lead to code injection vulnerabilities.",
        pattern=_compile(r"\beval\("),
        severity="high",
    ),
    Rule(
        id="JS002",
        description="Use of the Function constructor can lead to code injection.",
        pattern=_compile(r"new\s+Function\("),
        severity="high",
    ),
    Rule(
        id="JS003",
        description="Direct assignment to innerHTML can lead to XSS.",
        pattern=_compile(r"\.innerHTML\s*="),
        severity="medium",
    ),
    Rule(
        id="JS004",
        description="document.write() can lead to XSS when used with untrusted input.",
        pattern=_compile(r"document\.write\("),
        severity="medium",
    ),
    Rule(
        id="JS005",
        description="child_process.exec/execSync can be dangerous when used with untrusted input.",
        pattern=_compile(r"child_process\.exec(Sync)?\("),
        severity="high",
    ),
)

# TypeScript rules build on the JavaScript rules with a few TS/Angular-specific checks
TYPESCRIPT_RULES: Sequence[Rule] = JAVASCRIPT_RULES + (
    Rule(
        id="TS001",
        description="Use of 'any' type weakens type safety and can hide security issues.",
        pattern=_compile(r":\s*any\b|as\s+any\b"),
        severity="medium",
    ),
    Rule(
        id="TS002",
        description="Use of // @ts-ignore may hide type errors with security impact.",
        pattern=_compile(r"//\s*@ts-ignore"),
        severity="low",
    ),
    Rule(
        id="TS003",
        description="DomSanitizer.bypassSecurityTrust* can be dangerous if used with untrusted input.",
        pattern=_compile(r"bypassSecurityTrust(Html|Url|Style|ResourceUrl|Script)\("),
        severity="medium",
    ),
    Rule(
        id="TS004",
        description="Direct DOM access via nativeElement can bypass Angular's templating safety.",
        pattern=_compile(r"nativeElement\.[A-Za-z_]\w*"),
        severity="medium",
    ),
    Rule(
        id="TS005",
        description="Possible hard-coded secret (apiKey/token/secret/password) in TypeScript code.",
        pattern=_compile(r"(apiKey|token|secret|password)\s*[:=]\s*['\"].+['\"]", ignore_case=True),
        severity="medium",
    ),
)


JAVA_RULES: Sequence[Rule] = (
    Rule(
        id="JAVA001",
        description="Runtime.exec() can be dangerous and lead to command injection.",
        pattern=_compile(r"Runtime\.getRuntime\(\)\.exec\("),
        severity="high",
    ),
    Rule(
        id="JAVA002",
        description="Use of weak hash algorithms (MD5/SHA1).",
        pattern=_compile(r"MessageDigest\.getInstance\(\s*\"(MD5|SHA-1|SHA1)\""),
        severity="medium",
    ),
    Rule(
        id="JAVA003",
        description="Java deserialization using ObjectInputStream can be dangerous with untrusted data.",
        pattern=_compile(r"ObjectInputStream"),
        severity="high",
    ),
    Rule(
        id="JAVA004",
        description="Possible use of dynamic SQL via java.sql.Statement; prefer PreparedStatement.",
        pattern=_compile(r"java\.sql\.Statement|Statement\s+\w+\s*="),
        severity="medium",
    ),
    Rule(
        id="JAVA005",
        description="Possible hard-coded password.",
        pattern=_compile(r"String\s+password\s*=\s*\".+\""),
        severity="medium",
    ),
)


LANGUAGE_RULES: Dict[str, Sequence[Rule]] = {
    "python": PYTHON_RULES,
    "javascript": JAVASCRIPT_RULES,
    "typescript": TYPESCRIPT_RULES,
    "java": JAVA_RULES,
}


def detect_language(path: Path) -> Optional[str]:
    """Return a language name for the given file path, or None if unknown."""

    return EXTENSION_LANGUAGE.get(path.suffix.lower())


def scan_text(
    *, language: str, file_path: Path, text: str
) -> List[Vulnerability]:
    """Scan the given text using rules for the specified language."""

    rules = LANGUAGE_RULES.get(language)
    if not rules:
        return []

    findings: List[Vulnerability] = []
    lines = text.splitlines()

    for line_no, line in enumerate(lines, start=1):
        for rule in rules:
            if rule.pattern.search(line):
                findings.append(
                    Vulnerability(
                        rule_id=rule.id,
                        description=rule.description,
                        severity=rule.severity,
                        language=language,
                        file_path=str(file_path),
                        line=line_no,
                        code=line.strip(),
                    )
                )

    return findings


def scan_file(path: Path) -> List[Vulnerability]:
    """Scan a single file for potential vulnerabilities."""

    language = detect_language(path)
    if language is None:
        return []

    try:
        # Use errors="ignore" to avoid issues with mixed encodings.
        text = path.read_text(encoding="utf-8", errors="ignore")
    except OSError:
        return []

    return scan_text(language=language, file_path=path, text=text)


def iter_project_files(root: Path) -> Iterable[Path]:
    """Yield source files under *root* while skipping typical dependency dirs."""

    root = root.resolve()

    if root.is_file():
        yield root
        return

    for dirpath, dirnames, filenames in os.walk(root):
        # In-place filter of directories to avoid walking large dependency trees.
        dirnames[:] = [
            d for d in dirnames
            if d not in EXCLUDED_DIRS
        ]

        for filename in filenames:
            full_path = Path(dirpath, filename)
            if detect_language(full_path) is not None:
                yield full_path


def scan_project(root: Path) -> List[Vulnerability]:
    """Scan all supported source files under *root* and return findings."""

    findings: List[Vulnerability] = []

    for path in iter_project_files(root):
        findings.extend(scan_file(path))

    return findings
